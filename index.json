[{"content":"AOP（Aspect Oriented Programming）意即面向切面编程，是通过预编译方式和运行期动态代理的方式来实现程序功能统一维护的技术。\n基本术语解释  切面（Aspect）：泛指切入点和通知等的集合，即对主业务逻辑的增强 连接点（Join Point）：指一些程序执行过程的特殊位置，例如方法的运行或者异常的处理，在 Spring 中，它总是指某个程序的执行。 通知（Advice）：切面在特定连接点采取的动作，存在 around、before 和 after 等类型的通知。 切入点（Point Cut）：匹配连接点的集合（A predicate that matches join points） 织入（Weave）：指对主业务逻辑的增强过程 目标对象（Target）：切面增强的目标 顾问（Advisor）：切面的另一种实现，可将通知以复杂方式织入目标对象，是将 advice 包装为复杂切面的装配器 代理（Proxy）：切面增强后的对象  JoinPoint and PointCut  A Joinpoint is a point in the control flow of a program where the control flow can arrive via two different paths(IMO : that\u0026rsquo;s why call joint).\nAdvice describes a class of functions which modify other functions.\nA Pointcut is a matching Pattern of Joinpoint i.e. set of join points.\n 从静态代理到动态代理 通过代理模式，客户可以避免直接和服务交互，而是通过实现同样接口的代理类来进行交互。\n静态代理（Static Proxy） 在编译时静态代理就已经实现，编译完成后，代理类就是一个 class 文件。 动态代理（Dynamic Proxy） 静态代理在使用过程中需要对每个相应的类都编写对应的代理类，当功能多了以后，就会产生很多类，从而使项目变得臃肿。动态代理则解决了这个问题。\n动态代理在运行时动态生成，编译完成时没有实际的 class 文件，而是在运行时动态生成字节码，并加载到内存中运行。\n在 Java 中主要利用 java.lang.reflect.proxy 和 java.lang.reflect.InvocationHandler 实现。通过实现 InvocationHandler 类，可以为多个类提供代理，然后通过 Proxy 类可以为对应的类生成代理实例。\nSpring Framework 中的 AOP Reference","permalink":"https://zhiwenliang.github.io/posts/2021/10/aop-conslusion/","summary":"\u003cp\u003eAOP（Aspect Oriented Programming）意即面向切面编程，是通过预编译方式和运行期动态代理的方式来实现程序功能统一维护的技术。\u003c/p\u003e","title":"AOP 学习总结"},{"content":"在分布式系统中，CAP 和 BASE 是其中重要的基础理论。\nCAP 理论：  C: Consistency（一致性） A: Availability（可用性） P: Partition tolerance（分区容错性）  首先说 Partition tolerance，在多个节点组成的分布式系统中，节点之间的网络之间正常情况下是互相连通的，但是意外发生时，节点之间不能连通，系统内就变成了不同的分区，比如北京的和上海之间的网络故障就会导致分区的产生，如果数据只存在一个分区的节点上，那么就会导致这些数据对其他分区不可见，此时的系统是不具有分区容错性的。\n为了提高分区的容错性，我们可以把节点上的数据复制到多个分区的多个节点上，这样即使意外发生，上面的数据仍然可以访问，即满足了分区容错性。\n从不同节点访问同样的数据时，可能存在以下问题：\n 不同节点上数据不一致（不满足 Consistency） 不能及时返回数据（不满足 Availability）  那么如何解决呢？\n 为了满足 Consistency，向其他节点复制数据时，等待所有节点全部写操作完成后才允许读操作，但是这样在写操作期间应用无法从这些节点获取数据，就牺牲了 Availability 为了满足 Availability，向其他节点复制数据时，不用等所有节点全部操作完成就允许访问数据，但这样就会牺牲 Consistency ，获取的数据可能不一致  综上，在分布式系统中，满足分区容错性的前提下，可用性和一致性只能满足一个。\nBASE 理论 在实际生产实践中，基于 CAP 理论，延伸出了 BASE 理论。\n Basically Available（基本可用） Soft State（软状态） Eventually Consistent（最终一致性）  其本质上是通过牺牲强一致性，允许数据存在一个同步过程中的中间状态\nReference  https://www.ruanyifeng.com/blog/2018/07/cap.html https://www.cnblogs.com/duanxz/p/5229352.html ","permalink":"https://zhiwenliang.github.io/posts/2021/09/cap-and-base/","summary":"\u003cp\u003e在分布式系统中，CAP 和 BASE 是其中重要的基础理论。\u003c/p\u003e","title":"CAP 和 BASE 理论"},{"content":"这是我使用 Hugo 搭建博客的过程。\n为何使用 Hugo 之前我是使用 Hexo 来生成并部署对应的博客站点的，在使用过程中，对 GitHub Pages 等了解逐渐加深，发现这就是一个静态站点托管服务，我只要能生成相应的站点内容并发布到指定仓库就好了。\nHexo 作为一个比较成熟且易用的工具，包含了大量的炫酷主题和功能，但是作为一个简单的博客站点，其实并不需要很多功能，思考和写更多的优质内容，才是最重要的事情。\nHexo 需要安装 npm，Node 还有相应的依赖等工具，相对于 Hugo 还是比较笨重的，而且生成速度方面 Hugo 是完胜的，基本上瞬间就可以生成，使用体验极好。\n至于页面效果方面，我并没有太大要求，索性直接选择了一个极简的主题——PaperMod，基本像标签，分类和搜索等功能都可以具备，页面风格和访问速度也很让我满意。\n具体搭建流程  下载编译 Hugo。  如果选择编译好的对应平台文件，直接将此文件加到环境变量中就可以在命令行中执行各种命令了 如果想使用最新的 Hugo，就需要自己编译安装了，先参考 GoLang 官网安装教程 安装 Go 语言环境，然后参考 Hugo 官方文档 安装即可 其他各种安装方式在 Hugo 官网中都有相应的描述，参照进行操作即可   在一个目标目录下执行 hugo new site \u0026lt;blog directory\u0026gt; 生成博客对应目录，下面会生成对应的各种文件和目录，大致目录结构如下：  . ├── archetypes （模板文件，生成新的文章时使用） ├── assets （可选，Hugo Pipes 会用到一些文件） ├── config.toml （自定义配置文件，可以改成 yaml 或者 Json 格式的配置） ├── content （网站实际的文章内容） ├── data （可选，生成网站时用到的配置文件） ├── layouts （可选，一些网站布局方面的模板） ├── public （执行生成网站内容命令后出现，其中是网站的全部内容，直接推送到GitHub Pages 对应仓库即可生效） ├── static （网站的静态内容，生成网站时会直接被拷贝到网站根目录下） └── themes （网站的主题，可以选择心仪的主题然后配置即可使用） 添加主题到 themes 目录下，这个在各个主题的官网或者仓库下都有对应的说明 根据主题，修改根目录下的 config.toml 配置站点，达到不同网站效果，这是我 使用 PaperMod 主题后的配置文件（使用 yaml 格式）:  baseURL: \u0026#34;https://zhiwenliang.github.io\u0026#34; title: Zhiwen\u0026#39;s Blog paginate: 5 theme: hugo-PaperMod enableInlineShortcodes: true enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false enableEmoji: true # googleAnalytics: UA-123-45 minify: disableXML: true # minifyOutput: true languages: en: languageName: \u0026#34;English\u0026#34; weight: 1 menu: main: - name: Archive url: archives weight: 5 - name: Search url: search/ weight: 10 - name: Tags url: tags/ weight: 10 - name: Categories url: categories/ weight: 10 # fr: # languageName: \u0026#34;🇫🇷\u0026#34; # languageAltTitle: French # weight: 2 # title: PaperModL2 # profileMode: # enabled: true # title: PaperMod # # imageUrl: \u0026#34;#\u0026#34; # # imageTitle: my image # # imageWidth: 120 # # imageHeight: 120 # subtitle: \u0026#34;☄️ Fast | ☁️ Fluent | 🌙 Smooth | 📱 Responsive\u0026#34; # buttons: # - name: Blog # url: posts # - name: Tags # url: tags # menu: # main: # - name: Archive # url: archives/ # weight: 5 # - name: Tags # url: tags # weight: 10 # - name: Categories # url: categories # weight: 10 # - name: Series # url: series # weight: 10 # - name: NullLink # url: \u0026#34;#\u0026#34; # - name: NullLink2 # url: \u0026#34;#\u0026#34; # - name: NullLink3 # url: \u0026#34;#\u0026#34; # fa: # languagedirection: rtl # weight: 3 # title: PaperMod RTL # homeInfoParams: # Title: \u0026#34;Hi there \\U0001F44B\u0026#34; # Content: Welcome to RTL layout # menu: # main: # - name: Tags # url: tags # weight: 10 outputs: home: - HTML - RSS - JSON params: env: production # to enable google analytics, opengraph, twitter-cards and schema. description: \u0026#34;Zhiwen\u0026#39;s Blog\u0026#34; author: Zhiwen Liang # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors defaultTheme: auto # disableThemeToggle: true ShowShareButtons: false ShowReadingTime: true # disableSpecial1stPost: true displayFullLangName: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true ShowToc: true # comments: false # images: [\u0026#34;papermod-cover.png\u0026#34;] # profileMode: # enabled: false # title: PaperMod # imageUrl: \u0026#34;#\u0026#34; # imageTitle: my image # # imageWidth: 120 # # imageHeight: 120 # buttons: # - name: Archives # url: archives # - name: Tags # url: tags homeInfoParams: Title: \u0026#34;Zhiwen\u0026#39;s Blog\u0026#34; Content: \u0026gt; Welcome to Zhiwen\u0026#39;s Blog. socialIcons: - name: GitHub url: \u0026#34;https://github.com/zhiwenliang\u0026#34; - name: email url: \u0026#34;mailto:zhiwen_liang@outlook.com\u0026#34; - name: RSS url: \u0026#34;index.xml\u0026#34; editPost: URL: \u0026#34;mailto:zhiwen_liang@outlook.com?subject=Suggesting changes for \u0026#34; Text: \u0026#34;Suggest\u0026#34; # edit text appendFilePath: true # to append file path to Edit link # label: # text: \u0026#34;Home\u0026#34; # icon: icon.png # iconHeight: 35 # analytics: # google: # SiteVerificationTag: \u0026#34;XYZabc\u0026#34; assets: favicon: \u0026#34;logo/favicon-16x16.png\u0026#34; favicon16x16: \u0026#34;logo/favicon-16x16.png\u0026#34; favicon32x32: \u0026#34;logo/favicon-32x32.png\u0026#34; apple_touch_icon: \u0026#34;logo/apple-touch-icon.png\u0026#34; safari_pinned_tab: \u0026#34;logo/apple-touch-icon.png\u0026#34; # cover: # hidden: true # hide everywhere but not in structured data # hiddenInList: true # hide on list pages and home # hiddenInSingle: true # hide on single page fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] # taxonomies: # category: categories # tag: tags # series: series # markup: # goldmark: # renderer: # unsafe: true # highlight: # # anchorLineNos: true # codeFences: true # guessSyntax: true # lineNos: true # # noClasses: false # style: monokai # privacy: # vimeo: # disabled: false # simple: true # twitter: # disabled: false # enableDNT: true # simple: true # instagram: # disabled: false # simple: true # youtube: # disabled: false # privacyEnhanced: true # services: # instagram: # disableInlineCSS: true # twitter: # disableInlineCSS: true 进入目录，执行 hexo new /posts/new-blog.md 即根据模板生成文件，然后在其中编写博客内容 在目录下执行 hugo server，就可以在指定站点预览到我们的网站，默认是 http://localhost:1313/  配置 Github Action 每次都要手动推送到对应仓库实在麻烦，不过可以通过 GitHub Actions 来自动化这一操作，我们需在 GitHub 上新建两个仓库，仓库一是 GitHub Pages 对应展示的仓库，仓库二是用来生成博客相关内容的目录和我们本地的目录相对应，我们需要在仓库二中添加对应 GitHub Actions 相应文件。我的 workflow 文件配置如下：\nname: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: # github_token: ${{ secrets.GITHUB_TOKEN }} deploy_key: ${{secrets.ACTIONS_DEPLOY_KEY}} external_repository: zhiwenliang/zhiwenliang.github.io publish_branch: main publish_dir: ./public 两个仓库需要分别配置一对密钥，仓库一在 Settings 中的 Deploy Keys 中配置公钥，仓库二在 Settings 中的 Secrets 中配置私钥。\n配置完成后，每次向仓库二推送改动后，都会触发 Hugo 的构建，并自动部署到仓库一中，网站也会发生对应改动。\nReference  Hugo Offical Documentation Hugo PaperMod ","permalink":"https://zhiwenliang.github.io/posts/2021/09/build-blog-hugo/","summary":"\u003cp\u003e这是我使用 Hugo 搭建博客的过程。\u003c/p\u003e","title":"使用 Hugo 创建静态博客"},{"content":"这是我使用Hexo搭建以及改造博客的过程记录。\n搭建博客 主要参考 Hexo 官方文档 即可\nhexo init \u0026lt;the directory of your blog\u0026gt; cd \u0026lt;blog directory\u0026gt; npm install 至此一个简单的 hexo 博客的本地环境就已经搭建完成，输入 hexo s ，即可在 http://localhost:4000 上看到网站的预览。\n接下来如果需要其他功能，就需要修改相关的配置文件和安装插件。虽然有很多更炫酷的功能，但考虑到折腾越少，麻烦越少，并且方便升级和重建，而且最终写博客才是重点，最终我选择 hexo-deployer-git 、hexo-generator-feed 和 hexo-generator-searchdb 这三个插件，主题用 NexT， 并将环境配置的命令写入脚本，方便以后的使用。\n搭建多终端博客环境 首先搞清楚本地生成博客并推送到 GitHub 的大致过程\n  本地输入 hexo g 会生成 public 文件夹，输入 hexo clean 会删除此文件夹，此文件夹下内容就是网站所需的源代码，也是我们 push 到 GitHub 仓库的内容。\n  使用 hexo d 会生成 .deploy_git 文件夹，打开发现这是一个 Git 仓库，主体内容和 public 文件夹的内容相同，应该是通过 hexo-deployer-git 插件生成，用于将仓库内容 push 到 GitHub 上远程仓库的 master 分支上。\n  再看下 GitHub 上的远程仓库，master 分支上存储生成的静态网站代码会自动部署到 GitHub Pages 上，猜测其他分支上的内容不会影响 blog 网站的内容。查看 GitHub 官方文档，并通过测试发现确实如此。\n  如此一来多终端编辑 hexo 博客的实现思路就很清晰了：在 GitHub 上的仓库新建分支，在此分支存储用于生成博客的源文件，在其他终端上 clone 对应仓库，切换到刚刚新建的分支运行环境配置脚本即可以开始编辑博客。\ngit init git remote add origin \u0026lt;the repository of your blog\u0026gt; git add -A git commit -m \u0026#34;Source files of the blog\u0026#34; git checkout -b hexo git push origin hexo   至此，多终端编辑博客的环境便搭建完成。\n虽然最终折腾成功，但是相比 WordPress 部署后在任何地方都可以打开网页后台编辑，还是感觉很不方便，简单查了下，觉的 Hexo 经过一些配置后应该也可以实现这个功能，但是目前重点是先开始坚持写博客，所以还是少折腾，等以后再进行优化吧。\n私人仓库存储博客运行环境 最新写的东西都是断断续续的，有的草稿不太想发到网上，用了 hexo new draft 突然发现 GitHub Page 对应仓库是公开状态，草稿也是能看到的，想起来 GitHub 可以新建私人仓库，索性将原来仓库的 hexo 分支删除，新建了一个私人仓库用于存储博客写作环境相关源文件，这样的对于隐私的控制性明显更强。操作方法也很简单，\n  在 GitHub 上新建一个私人仓库。\n  回到本地 git clone \u0026lt;repo_address\u0026gt; \u0026lt;local_directory_name\u0026gt;，将原博客文件夹中除 .git 文件夹外全部 copy 到新的文件夹中。\n  在新的博客文件夹下执行以下命令：\ngit add -A git commit -m \u0026lt;commit_messsage\u0026gt; git push   迁移完成，以后每次写完博客却先不想发布时，可以先提交到这个私人仓库。\n  gitee 好像也推出了静态页面托管服务，国内访问速度可以更快点，搭建方法和 GitHub 基本一致，但是如果不是 pro 用户，不能自动更新仓库里面的内容到页面上，需要每次手动更新。\n  添加 PlantUML 插件   安装插件：在博客目录下执行以下命令\nnpm install hexo-tag-plantuml --save   然后在 _config.yml 文件中添加以下内容\ntag_plantuml: type: static # static 代表下载 svg 代码到生成的html 中，dynamic 代表从 http://www.plantuml.com/plantuml/svg 动态生成   在 markdown 文件中编写时按照此格式\n{% plantuml %} Bob-\u0026gt;Alice : hello {% endplantuml %}   添加 mermaid 插件 mermaid 插件相较于 PlantUML 插件更适合 markdown\n 直接可以在代码块中编写 在 vscode 中安装 mermaid 相应插件后可以在写作时实时预览 现在 Hexo NexT 主题添加了对应的支持，可以直接开启，原来未支持前需要手动修改部分文件实现  出于以上原因，我更换了画图的插件，通过以下步骤可以安装\n  安装插件：在博客目录下执行以下命令\nnpm install hexo-filter-mermaid-diagrams --save   然后在 _config.yml 文件中添加以下内容\n# mermaid chart mermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: \u0026#34;8.8.1\u0026#34; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js startOnload: true # default true   在 markdown 文件中编写时可以直接编写到代码块中，需要定义代码格式为 mermaid\n  通过 npm 安装 NexT 主题 现在也可以通过 npm 安装 NexT 主题，这种方法方便更新，并且配置文件单独放置，方便修改。\n首先安装 hexo-theme-next 依赖\nnpm install hexo-theme-next 安装完成后，进入到博客文件夹的根目录，修改 Hexo 配置文件 _config.yml，修改主题配置为 theme: next。 如果不想使用默认配置的话，在 node_modules 目录下可以找到刚刚安装的 hexo-theme-next，将_config.yml文件拷贝过来，并重新命名为 _config.next.yml，在此可以对主题进行各种配置。 至此主题安装完成。\nReference  mermaid offical documentation hexo-filter-mermaid-diagrams ","permalink":"https://zhiwenliang.github.io/posts/2021/09/build-blog-hexo/","summary":"\u003cp\u003e这是我使用Hexo搭建以及改造博客的过程记录。\u003c/p\u003e","title":"使用 Hexo 创建静态博客"}]