[{"content":"以前用家里闲置的笔记本玩过 lean 的软路由，但是需要电脑一直开着，而且它的网卡和路由器的专用芯片和固件相比肯定是不如的，所以我一直希望有一台真正可以刷入相关固件的路由器。相比网件、华硕等路由器，我很简单的需求更适合 200 元左右的小米 AC2100。\n如何刷机 现在主要的刷机大致有 2 个：\n 利用之前爆出的 CVE-2020-8597 漏洞开启 telnet 和 ssh 刷入 breed 或者 pb-boot，然后刷入想要的固件。 利用固件的 SSH 相关漏洞打开 SSH，然后刷入 breed 或者 pb-boot。  由于第一种方法需要较多的额外工具，我选择了第二种方法。\n刷入的固件也可以选择 pandvas 或者 Openwrt，现在 Openwrt 已经官方支持了 AC2100，所以刷入相关系统也是方便很多的。\n开启 ssh   电脑网口连接 Lan 口，浏览器打开 小米 AC2100 web 管理页面 ，简单设置后登录。\n  在登录后的页面 F12 打开网页后台，在控制台（Console）复制粘贴如下代码，Enter 执行。\n  function getSTOK() { let match = location.href.match(/;stok=(.*?)\\//); if (!match) { return null; } return match[1]; } function execute(stok, command) { command = encodeURIComponent(command); let path = `/cgi-bin/luci/;stok=${stok}/api/misystem/set_config_iotdev?bssid=SteelyWing\u0026amp;user_id=SteelyWing\u0026amp;ssid=-h%0A${command}%0A`; console.log(path); return fetch(new Request(location.origin + path)); } function enableSSH() { stok = getSTOK(); if (!stok) { console.error(\u0026#34;stok not found in URL\u0026#34;); return; } console.log(`stok = \u0026#34;${stok}\u0026#34;`); password = prompt(\u0026#34;Input new SSH password\u0026#34;); if (!password) { console.error(\u0026#34;You must input password\u0026#34;); return; } execute( stok, ` nvram set ssh_en=1 nvram commit sed -i \u0026#39;s/channel=.*/channel=\\\\\u0026#34;debug\\\\\u0026#34;/g\u0026#39; /etc/init.d/dropbear /etc/init.d/dropbear start ` ) .then((response) =\u0026gt; response.text()) .then((text) =\u0026gt; console.log(text)); console.log(\u0026#34;New SSH password: \u0026#34; + password); execute(stok, `echo -e \u0026#34;${password}\\\\n${password}\u0026#34; | passwd root`) .then((response) =\u0026gt; response.text()) .then((text) =\u0026gt; console.log(text)); } enableSSH(); 在网页上会弹出设置 root 账户密码的弹窗，设置后关闭。\n至此已经成功打开 SSH。\n上传固件并刷入 Breed 并设置  在本机命令行通过 ssh 登录路由器系统，账户为 root，密码即刚刚设置的。192.168.31.1 是路由器的默认内网 ip 地址。  ssh root@192.168.31.1 将本机的 breed 固件传输到 /tmp 目录下，执行如下命令：  nvram set uart_en=1 nvram set bootdelay=5 nvram set flag_try_sys1_failed=1 nvram commit mtd -r write [上传到tmp目录的固件地址] kernel1 如果路由器在 60 秒内重启则代表刷 BREED 成功(灯会从蓝变橘，最终变蓝进入系统)。成功后拔掉电源，按住 reset 同时接上电源等 10 秒即可。\n最后，浏览器打开 breed web 管理页面，刷入 Breed 成功。  通过 Breed 刷入 Openwrt  进入 breed 后增加环境变量 xiaomi.r3g.bootfw，值为 2。 在固件项选择对应的底包，然后上传刷入，后面按照对应固件的提示操作即可  刷砖后恢复小米原厂系统 由于过程中随时存在刷砖的风险，所以去 官方下载页 可以下载使用对应的官方工具刷入官方的 rom 然后重头再来。\nReference  永久开启小米/红米 AC2100 TELNET 和 SSH，可升级、降级和恢复出厂 AX3600/AX1800/AX5/AC2100 官方固件开启 SSH 方法 AC2100 OpenWrt Guide 小米 红米【AC2100】一键刷 BREED【30 秒刷完】小白帅小伙专用 检查坏块 | 无需 Telnet breed 刷机红米 AC2100 小米 AC2100 原厂固件官方固 红米 AC2100 刷机及固件资源汇总附送 Lean 源码固件 红米/小米 AC2100 刷入 r3g breed 以及恢复官方 boot 详细教程 红米/小米 AC2100 lean_openWRT 固件稳定养老版 ","permalink":"https://zhiwenliang.github.io/posts/2021/10/ac2100-breed-openwrt/","summary":"\u003cp\u003e以前用家里闲置的笔记本玩过 lean 的软路由，但是需要电脑一直开着，而且它的网卡和路由器的专用芯片和固件相比肯定是不如的，所以我一直希望有一台真正可以刷入相关固件的路由器。相比网件、华硕等路由器，我很简单的需求更适合 200 元左右的小米 AC2100。\u003c/p\u003e","title":"小米 AC2100 刷入 Breed 和 Openwrt 小记"},{"content":"面向对象三大特性  封装：将对象的属性和行为封装到一个类里，可以隐藏功能的实现细节。 继承：子类可以继承父类的特征和行为，提高代码的复用性和可维护性。 多态：值同一个行为具有多种表现形式和形态的能力。Java 中存在方法重载和对象多态（子类可以重写父类的方法）。  数据类型  基本数据类型：数值型（byte，short，int，long，float，double，），字符型（char），布尔型（boolean） 引用数据类型：类，接口和数组  抽象类和接口  接口类是抽象类的变体，接口中的所有方法全部是抽象的，抽象类声明方法的存在而不实现 接口可以继承，抽象类不行  重载和重写  重载的方法名相同即可，参数列表必须不同 重写的方法签名必须相同  ArrayList 和 LinkedList  ArrayList 基于数组，在内存是连续的存储结构，查询较快，新增删除较慢 LinkedList 基于双向链表，在内存是不连续的存储结构，但是新增和删除较快，因为它只需要删除和  HashMap  数据结构：数组 + 链表 + 红黑树 插入数据的方式：尾插法 hash 值计算方式：2 次扰动处理 扩容策略：插入后扩容  HashMap 是线程不安全的，在多个线程对同一个 HashMap 操作时，容易造成数据的覆盖。\n可以通过直接加锁，使用 HashTable 和使用 ConcurentHashMap 等方法来解决线程不安全的问题。\n泛型 泛型可以理解为参数化类型（parameterized type），即在调用时再明确实际的类型。\n它也是程序设计语言的一种风格和范式，在 C++ 中也被称为模板。\n在 Java 中，泛型其实是一种伪泛型，在编译期间会进行泛型擦除的操作，在运行时是无法获取泛型参数的类型的。\n进程和线程 进程是系统进行资源分配和调度的基本单位。\n线程是比线程更小的能独立运行的基本单位，它的上下文切换成本低于线程，可以提供更好的并发性能。\nvolatile 用来修饰变量，修饰的变量在每次变化后都会直接刷新到共享内存中，可以保证变量对所有线程的可见性。\n也可以用来禁止指令重排序。\nsynchronized 锁升级 无锁 -\u0026gt; 偏向锁 -\u0026gt; 自旋锁 -\u0026gt; 重量级锁\n核心是减少用户态到核心态的切换，提高锁的效率，从 jvm 层面优化锁。\nCAS Compare and Swap，是用来刷新内存值的一个操作，主要涉及到三个值：内存值，原值，新值，内存值和原值相等时，更换内存值为新值，否则不做操作。\nReentrantLock 可重入锁，即线程可以重复获取锁，\n多线程的创建 可以通过继承 Thread 类，实现 Runable 接口和线程池创建线程等方式来创建线程。\n线程池 参数：\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize \u0026lt; 0 || maximumPoolSize \u0026lt;= 0 || maximumPoolSize \u0026lt; corePoolSize || keepAliveTime \u0026lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } 单例模式  懒汉式：使用时才进行初始化 饿汉式：类加载时就进行初始化  public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } Reference","permalink":"https://zhiwenliang.github.io/posts/interview/java-basis/","summary":"","title":"面试 - Java 基础总结"},{"content":"AOP（Aspect Oriented Programming）意即面向切面编程，是通过预编译方式和运行期动态代理的方式来实现程序功能统一维护的技术。\n基本术语解释  切面（Aspect）：泛指切入点和通知等的集合，即对主业务逻辑的增强 连接点（Join Point）：指一些程序执行过程的特殊位置，例如方法的运行或者异常的处理，在 Spring 中，它总是指某个程序的执行。 通知（Advice）：切面在特定连接点采取的动作，在 Spring AOP 中存在 around、before 和 after 等类型的通知。 切入点（Point Cut）：匹配连接点的集合（A predicate that matches join points） 织入（Weave）：指对主业务逻辑的增强过程 目标对象（Target）：切面增强的目标 顾问（Advisor）：切面的另一种实现，可将通知以复杂方式织入目标对象，是将 advice 包装为复杂切面的装配器 代理（Proxy）：切面增强后的对象  JoinPoint and PointCut  A Joinpoint is a point in the control flow of a program where the control flow can arrive via two different paths(IMO : that\u0026rsquo;s why call joint).\nAdvice describes a class of functions which modify other functions.\nA Pointcut is a matching Pattern of Joinpoint i.e. set of join points.\n 从静态代理到动态代理 通过代理模式，客户可以避免直接和服务交互，而是通过实现同样接口的代理类来进行交互。\n静态代理（Static Proxy） 在编译时静态代理就已经实现，编译完成后，代理类就是一个 class 文件。 动态代理（Dynamic Proxy） 静态代理在使用过程中需要对每个相应的类都编写对应的代理类，当功能多了以后，就会产生很多类，从而使项目变得臃肿。动态代理则解决了这个问题。\n动态代理在运行时动态生成，编译完成时没有实际的 class 文件，而是在运行时动态生成字节码，并加载到内存中运行。\nJava 中常见的代理有 JDK 动态代理和 CGLIB 动态代理。\nJDK 动态代理主要利用 java.lang.reflect.proxy 和 java.lang.reflect.InvocationHandler 通过反射机制实现。通过实现 InvocationHandler 类，可以为多个类提供代理，然后通过 Proxy 类可以为对应的类生成代理实例。\nCGLIB 动态代理则主要利用 ASM 框架，通过修改字节码来生成子类来生成代理。\nSpring Framework 中的 AOP Spring Framework 默认使用标准的 JDK 动态代理来实现 AOP 代理，但是只能代理接口类。对于没有实现接口类的类，Spring Framework 会默认使用 CGLIB 进行代理。\nSpring AOP 中只支持方法执行类型的 Join Point。现在，Spring Framework 已经支持了 AspectJ，我们可以采用 @AspectJ 的风格来编写 PointCut 的声明，大大简化了我们的代码。\nPointCut 有多种标识符，最常用的是 execution，它可以用来匹配方法执行类型的 Join Point。\nSpring AOP 主要用来解决非业务代码的抽取。\n常见应用  记录日志 监控程序性能 权限控制 缓存优化 事务管理 错误处理  Reference  Spring Framwork Doc ","permalink":"https://zhiwenliang.github.io/posts/2021/10/aop-conslusion/","summary":"\u003cp\u003eAOP（Aspect Oriented Programming）意即面向切面编程，是通过预编译方式和运行期动态代理的方式来实现程序功能统一维护的技术。\u003c/p\u003e","title":"AOP 总结"},{"content":"在分布式系统中，CAP 和 BASE 是其中重要的基础理论。\nCAP 理论：  C: Consistency（一致性） A: Availability（可用性） P: Partition tolerance（分区容错性）  首先说 Partition tolerance，在多个节点组成的分布式系统中，节点之间的网络之间正常情况下是互相连通的，但是意外发生时，节点之间不能连通，系统内就变成了不同的分区，比如北京的和上海之间的网络故障就会导致分区的产生，如果数据只存在一个分区的节点上，那么就会导致这些数据对其他分区不可见，此时的系统是不具有分区容错性的。\n为了提高分区的容错性，我们可以把节点上的数据复制到多个分区的多个节点上，这样即使意外发生，上面的数据仍然可以访问，即满足了分区容错性。\n从不同节点访问同样的数据时，可能存在以下问题：\n 不同节点上数据不一致（不满足 Consistency） 不能及时返回数据（不满足 Availability）  那么如何解决呢？\n 为了满足 Consistency，向其他节点复制数据时，等待所有节点全部写操作完成后才允许读操作，但是这样在写操作期间应用无法从这些节点获取数据，就牺牲了 Availability，类似于数据库事务中 Repeatable Read 隔离级别 为了满足 Availability，向其他节点复制数据时，不用等所有节点全部操作完成就允许访问数据，但这样就会牺牲 Consistency ，获取的数据可能不一致，类似于数据库事务中 Read Commited 隔离级别  综上，在分布式系统中，满足分区容错性的前提下，可用性和一致性只能满足一个。\nBASE 理论 在实际生产实践中，基于 CAP 理论，延伸出了 BASE 理论。\n Basically Available（基本可用） Soft State（软状态） Eventually Consistent（最终一致性）  其本质上是通过牺牲强一致性，允许数据存在一个同步过程中的中间状态\nReference  https://www.ruanyifeng.com/blog/2018/07/cap.html https://www.cnblogs.com/duanxz/p/5229352.html ","permalink":"https://zhiwenliang.github.io/posts/2021/09/cap-and-base/","summary":"\u003cp\u003e在分布式系统中，CAP 和 BASE 是其中重要的基础理论。\u003c/p\u003e","title":"CAP 和 BASE 理论"},{"content":"这是我使用 Hugo 搭建博客的过程。\n为何使用 Hugo 之前我是使用 Hexo 来生成并部署对应的博客站点的，在使用过程中，对 GitHub Pages 等了解逐渐加深，发现这就是一个静态站点托管服务，我只要能生成相应的站点内容并发布到指定仓库就好了。\nHexo 作为一个比较成熟且易用的工具，包含了大量的炫酷主题和功能，但是作为一个简单的博客站点，其实并不需要很多功能，思考和写更多的优质内容，才是最重要的事情。\nHexo 需要安装 npm，Node 还有相应的依赖等工具，相对于 Hugo 还是比较笨重的，而且生成速度方面 Hugo 是完胜的，基本上瞬间就可以生成，使用体验极好。\n至于页面效果方面，我并没有太大要求，索性直接选择了一个极简的主题——PaperMod，基本像标签，分类和搜索等功能都可以具备，页面风格和访问速度也很让我满意。\n具体搭建流程  下载编译 Hugo。  如果选择编译好的对应平台文件，直接将此文件加到环境变量中就可以在命令行中执行各种命令了 如果想使用最新的 Hugo，就需要自己编译安装了，先参考 GoLang 官网安装教程 安装 Go 语言环境，然后参考 Hugo 官方文档 安装即可 其他各种安装方式在 Hugo 官网中都有相应的描述，参照进行操作即可   在一个目标目录下执行 hugo new site \u0026lt;blog directory\u0026gt; 生成博客对应目录，下面会生成对应的各种文件和目录，大致目录结构如下：  . ├── archetypes （模板文件，生成新的文章时使用） ├── assets （可选，Hugo Pipes 会用到一些文件） ├── config.toml （自定义配置文件，可以改成 yaml 或者 Json 格式的配置） ├── content （网站实际的文章内容） ├── data （可选，生成网站时用到的配置文件） ├── layouts （可选，一些网站布局方面的模板） ├── public （执行生成网站内容命令后出现，其中是网站的全部内容，直接推送到GitHub Pages 对应仓库即可生效） ├── static （网站的静态内容，生成网站时会直接被拷贝到网站根目录下） └── themes （网站的主题，可以选择心仪的主题然后配置即可使用） 添加主题到 themes 目录下，这个在各个主题的官网或者仓库下都有对应的说明 根据主题，修改根目录下的 config.toml 配置站点，达到不同网站效果，这是我 使用 PaperMod 主题后的配置文件（使用 yaml 格式）:  baseURL: \u0026#34;https://zhiwenliang.github.io\u0026#34; title: Zhiwen\u0026#39;s Blog paginate: 5 theme: hugo-PaperMod enableInlineShortcodes: true enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false enableEmoji: true # googleAnalytics: UA-123-45 minify: disableXML: true # minifyOutput: true languages: en: languageName: \u0026#34;English\u0026#34; weight: 1 menu: main: - name: Archive url: archives weight: 5 - name: Search url: search/ weight: 10 - name: Tags url: tags/ weight: 10 - name: Categories url: categories/ weight: 10 # fr: # languageName: \u0026#34;🇫🇷\u0026#34; # languageAltTitle: French # weight: 2 # title: PaperModL2 # profileMode: # enabled: true # title: PaperMod # # imageUrl: \u0026#34;#\u0026#34; # # imageTitle: my image # # imageWidth: 120 # # imageHeight: 120 # subtitle: \u0026#34;☄️ Fast | ☁️ Fluent | 🌙 Smooth | 📱 Responsive\u0026#34; # buttons: # - name: Blog # url: posts # - name: Tags # url: tags # menu: # main: # - name: Archive # url: archives/ # weight: 5 # - name: Tags # url: tags # weight: 10 # - name: Categories # url: categories # weight: 10 # - name: Series # url: series # weight: 10 # - name: NullLink # url: \u0026#34;#\u0026#34; # - name: NullLink2 # url: \u0026#34;#\u0026#34; # - name: NullLink3 # url: \u0026#34;#\u0026#34; # fa: # languagedirection: rtl # weight: 3 # title: PaperMod RTL # homeInfoParams: # Title: \u0026#34;Hi there \\U0001F44B\u0026#34; # Content: Welcome to RTL layout # menu: # main: # - name: Tags # url: tags # weight: 10 outputs: home: - HTML - RSS - JSON params: env: production # to enable google analytics, opengraph, twitter-cards and schema. description: \u0026#34;Zhiwen\u0026#39;s Blog\u0026#34; author: Zhiwen Liang # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors defaultTheme: auto # disableThemeToggle: true ShowShareButtons: false ShowReadingTime: true # disableSpecial1stPost: true displayFullLangName: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true ShowToc: true # comments: false # images: [\u0026#34;papermod-cover.png\u0026#34;] # profileMode: # enabled: false # title: PaperMod # imageUrl: \u0026#34;#\u0026#34; # imageTitle: my image # # imageWidth: 120 # # imageHeight: 120 # buttons: # - name: Archives # url: archives # - name: Tags # url: tags homeInfoParams: Title: \u0026#34;Zhiwen\u0026#39;s Blog\u0026#34; Content: \u0026gt; Welcome to Zhiwen\u0026#39;s Blog. socialIcons: - name: GitHub url: \u0026#34;https://github.com/zhiwenliang\u0026#34; - name: email url: \u0026#34;mailto:zhiwen_liang@outlook.com\u0026#34; - name: RSS url: \u0026#34;index.xml\u0026#34; editPost: URL: \u0026#34;mailto:zhiwen_liang@outlook.com?subject=Suggesting changes for \u0026#34; Text: \u0026#34;Suggest\u0026#34; # edit text appendFilePath: true # to append file path to Edit link # label: # text: \u0026#34;Home\u0026#34; # icon: icon.png # iconHeight: 35 # analytics: # google: # SiteVerificationTag: \u0026#34;XYZabc\u0026#34; assets: favicon: \u0026#34;logo/favicon-16x16.png\u0026#34; favicon16x16: \u0026#34;logo/favicon-16x16.png\u0026#34; favicon32x32: \u0026#34;logo/favicon-32x32.png\u0026#34; apple_touch_icon: \u0026#34;logo/apple-touch-icon.png\u0026#34; safari_pinned_tab: \u0026#34;logo/apple-touch-icon.png\u0026#34; # cover: # hidden: true # hide everywhere but not in structured data # hiddenInList: true # hide on list pages and home # hiddenInSingle: true # hide on single page fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] # taxonomies: # category: categories # tag: tags # series: series # markup: # goldmark: # renderer: # unsafe: true # highlight: # # anchorLineNos: true # codeFences: true # guessSyntax: true # lineNos: true # # noClasses: false # style: monokai # privacy: # vimeo: # disabled: false # simple: true # twitter: # disabled: false # enableDNT: true # simple: true # instagram: # disabled: false # simple: true # youtube: # disabled: false # privacyEnhanced: true # services: # instagram: # disableInlineCSS: true # twitter: # disableInlineCSS: true 进入目录，执行 hexo new /posts/new-blog.md 即根据模板生成文件，然后在其中编写博客内容 在目录下执行 hugo server，就可以在指定站点预览到我们的网站，默认是 http://localhost:1313/  配置 Github Action 每次都要手动推送到对应仓库实在麻烦，不过可以通过 GitHub Actions 来自动化这一操作，我们需在 GitHub 上新建两个仓库，仓库一是 GitHub Pages 对应展示的仓库，仓库二是用来生成博客相关内容的目录和我们本地的目录相对应，我们需要在仓库二中添加对应 GitHub Actions 相应文件。我的 workflow 文件配置如下：\nname: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: # github_token: ${{ secrets.GITHUB_TOKEN }} deploy_key: ${{secrets.ACTIONS_DEPLOY_KEY}} external_repository: zhiwenliang/zhiwenliang.github.io publish_branch: main publish_dir: ./public 两个仓库需要分别配置一对密钥，仓库一在 Settings 中的 Deploy Keys 中配置公钥，仓库二在 Settings 中的 Secrets 中配置私钥。\n配置完成后，每次向仓库二推送改动后，都会触发 Hugo 的构建，并自动部署到仓库一中，网站也会发生对应改动。\nReference  Hugo Offical Documentation Hugo PaperMod ","permalink":"https://zhiwenliang.github.io/posts/2021/09/build-blog-hugo/","summary":"\u003cp\u003e这是我使用 Hugo 搭建博客的过程。\u003c/p\u003e","title":"使用 Hugo 创建静态博客"},{"content":"这是我使用Hexo搭建以及改造博客的过程记录。\n搭建博客 主要参考 Hexo 官方文档 即可\nhexo init \u0026lt;the directory of your blog\u0026gt; cd \u0026lt;blog directory\u0026gt; npm install 至此一个简单的 hexo 博客的本地环境就已经搭建完成，输入 hexo s ，即可在 http://localhost:4000 上看到网站的预览。\n接下来如果需要其他功能，就需要修改相关的配置文件和安装插件。虽然有很多更炫酷的功能，但考虑到折腾越少，麻烦越少，并且方便升级和重建，而且最终写博客才是重点，最终我选择 hexo-deployer-git 、hexo-generator-feed 和 hexo-generator-searchdb 这三个插件，主题用 NexT， 并将环境配置的命令写入脚本，方便以后的使用。\n搭建多终端博客环境 首先搞清楚本地生成博客并推送到 GitHub 的大致过程\n  本地输入 hexo g 会生成 public 文件夹，输入 hexo clean 会删除此文件夹，此文件夹下内容就是网站所需的源代码，也是我们 push 到 GitHub 仓库的内容。\n  使用 hexo d 会生成 .deploy_git 文件夹，打开发现这是一个 Git 仓库，主体内容和 public 文件夹的内容相同，应该是通过 hexo-deployer-git 插件生成，用于将仓库内容 push 到 GitHub 上远程仓库的 master 分支上。\n  再看下 GitHub 上的远程仓库，master 分支上存储生成的静态网站代码会自动部署到 GitHub Pages 上，猜测其他分支上的内容不会影响 blog 网站的内容。查看 GitHub 官方文档，并通过测试发现确实如此。\n  如此一来多终端编辑 hexo 博客的实现思路就很清晰了：在 GitHub 上的仓库新建分支，在此分支存储用于生成博客的源文件，在其他终端上 clone 对应仓库，切换到刚刚新建的分支运行环境配置脚本即可以开始编辑博客。\ngit init git remote add origin \u0026lt;the repository of your blog\u0026gt; git add -A git commit -m \u0026#34;Source files of the blog\u0026#34; git checkout -b hexo git push origin hexo   至此，多终端编辑博客的环境便搭建完成。\n虽然最终折腾成功，但是相比 WordPress 部署后在任何地方都可以打开网页后台编辑，还是感觉很不方便，简单查了下，觉的 Hexo 经过一些配置后应该也可以实现这个功能，但是目前重点是先开始坚持写博客，所以还是少折腾，等以后再进行优化吧。\n私人仓库存储博客运行环境 最新写的东西都是断断续续的，有的草稿不太想发到网上，用了 hexo new draft 突然发现 GitHub Page 对应仓库是公开状态，草稿也是能看到的，想起来 GitHub 可以新建私人仓库，索性将原来仓库的 hexo 分支删除，新建了一个私人仓库用于存储博客写作环境相关源文件，这样的对于隐私的控制性明显更强。操作方法也很简单，\n  在 GitHub 上新建一个私人仓库。\n  回到本地 git clone \u0026lt;repo_address\u0026gt; \u0026lt;local_directory_name\u0026gt;，将原博客文件夹中除 .git 文件夹外全部 copy 到新的文件夹中。\n  在新的博客文件夹下执行以下命令：\ngit add -A git commit -m \u0026lt;commit_messsage\u0026gt; git push   迁移完成，以后每次写完博客却先不想发布时，可以先提交到这个私人仓库。\n  gitee 好像也推出了静态页面托管服务，国内访问速度可以更快点，搭建方法和 GitHub 基本一致，但是如果不是 pro 用户，不能自动更新仓库里面的内容到页面上，需要每次手动更新。\n  添加 PlantUML 插件   安装插件：在博客目录下执行以下命令\nnpm install hexo-tag-plantuml --save   然后在 _config.yml 文件中添加以下内容\ntag_plantuml: type: static # static 代表下载 svg 代码到生成的html 中，dynamic 代表从 http://www.plantuml.com/plantuml/svg 动态生成   在 markdown 文件中编写时按照此格式\n{% plantuml %} Bob-\u0026gt;Alice : hello {% endplantuml %}   添加 mermaid 插件 mermaid 插件相较于 PlantUML 插件更适合 markdown\n 直接可以在代码块中编写 在 vscode 中安装 mermaid 相应插件后可以在写作时实时预览 现在 Hexo NexT 主题添加了对应的支持，可以直接开启，原来未支持前需要手动修改部分文件实现  出于以上原因，我更换了画图的插件，通过以下步骤可以安装\n  安装插件：在博客目录下执行以下命令\nnpm install hexo-filter-mermaid-diagrams --save   然后在 _config.yml 文件中添加以下内容\n# mermaid chart mermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: \u0026#34;8.8.1\u0026#34; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js startOnload: true # default true   在 markdown 文件中编写时可以直接编写到代码块中，需要定义代码格式为 mermaid\n  通过 npm 安装 NexT 主题 现在也可以通过 npm 安装 NexT 主题，这种方法方便更新，并且配置文件单独放置，方便修改。\n首先安装 hexo-theme-next 依赖\nnpm install hexo-theme-next 安装完成后，进入到博客文件夹的根目录，修改 Hexo 配置文件 _config.yml，修改主题配置为 theme: next。 如果不想使用默认配置的话，在 node_modules 目录下可以找到刚刚安装的 hexo-theme-next，将_config.yml文件拷贝过来，并重新命名为 _config.next.yml，在此可以对主题进行各种配置。 至此主题安装完成。\nReference  mermaid offical documentation hexo-filter-mermaid-diagrams ","permalink":"https://zhiwenliang.github.io/posts/2021/09/build-blog-hexo/","summary":"\u003cp\u003e这是我使用Hexo搭建以及改造博客的过程记录。\u003c/p\u003e","title":"使用 Hexo 创建静态博客"}]